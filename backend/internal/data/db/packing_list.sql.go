// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: packing_list.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const packingListByID = `-- name: PackingListByID :one
SELECT
    id, created_at, updated_at, user_id, name, description, status, due_date, tags, days
FROM
    packing_lists
WHERE
    id = $1
`

func (q *Queries) PackingListByID(ctx context.Context, id uuid.UUID) (PackingList, error) {
	row := q.db.QueryRow(ctx, packingListByID, id)
	var i PackingList
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.DueDate,
		&i.Tags,
		&i.Days,
	)
	return i, err
}

const packingListCreate = `-- name: PackingListCreate :one
INSERT INTO
    packing_lists (user_id, name, description, due_date, days, tags, status)
VALUES
    ($1, $2, $3, $4, $5, $6, 'not-started') RETURNING id, created_at, updated_at, user_id, name, description, status, due_date, tags, days
`

type PackingListCreateParams struct {
	UserID      uuid.UUID
	Name        string
	Description string
	DueDate     pgtype.Date
	Days        int32
	Tags        []string
}

func (q *Queries) PackingListCreate(ctx context.Context, arg PackingListCreateParams) (PackingList, error) {
	row := q.db.QueryRow(ctx, packingListCreate,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.DueDate,
		arg.Days,
		arg.Tags,
	)
	var i PackingList
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.DueDate,
		&i.Tags,
		&i.Days,
	)
	return i, err
}

const packingListDeleteByID = `-- name: PackingListDeleteByID :exec
DELETE FROM
    packing_lists
WHERE
    id = $1
`

func (q *Queries) PackingListDeleteByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, packingListDeleteByID, id)
	return err
}

const packingListGetAllByUser = `-- name: PackingListGetAllByUser :many
SELECT
    pl.id, pl.created_at, pl.updated_at, pl.user_id, pl.name, pl.description, pl.status, pl.due_date, pl.tags, pl.days,
    COALESCE(item_counts.item_count, 0) AS item_count,
    COALESCE(item_counts.packed_count, 0) AS packed_count
FROM
    packing_lists pl
    LEFT JOIN (
        SELECT
            packing_list_id,
            COUNT(*) AS item_count,
            COUNT(*) FILTER (WHERE is_packed = TRUE) AS packed_count
        FROM
            packing_list_items
        GROUP BY
            packing_list_id
    ) item_counts ON pl.id = item_counts.packing_list_id
WHERE
    user_id = $1
ORDER BY
    -- Add this to the end of the order by clause so that items are ordered
    -- consistently within an ordered set for consistent results between pages
    pl.due_date ASC NULLS FIRST,

    -- For created_at
    CASE
        WHEN $2 :: text = 'created_at:asc' THEN pl.created_at
    END ASC NULLS LAST,
    CASE
        WHEN $2 = 'created_at:desc' THEN pl.created_at
    END DESC NULLS LAST
LIMIT
    $4 OFFSET $3
`

type PackingListGetAllByUserParams struct {
	UserID  uuid.UUID
	OrderBy string
	Offset  int32
	Limit   int32
}

type PackingListGetAllByUserRow struct {
	PackingList PackingList
	ItemCount   int64
	PackedCount int64
}

func (q *Queries) PackingListGetAllByUser(ctx context.Context, arg PackingListGetAllByUserParams) ([]PackingListGetAllByUserRow, error) {
	rows, err := q.db.Query(ctx, packingListGetAllByUser,
		arg.UserID,
		arg.OrderBy,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PackingListGetAllByUserRow
	for rows.Next() {
		var i PackingListGetAllByUserRow
		if err := rows.Scan(
			&i.PackingList.ID,
			&i.PackingList.CreatedAt,
			&i.PackingList.UpdatedAt,
			&i.PackingList.UserID,
			&i.PackingList.Name,
			&i.PackingList.Description,
			&i.PackingList.Status,
			&i.PackingList.DueDate,
			&i.PackingList.Tags,
			&i.PackingList.Days,
			&i.ItemCount,
			&i.PackedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const packingListGetAllByUserCount = `-- name: PackingListGetAllByUserCount :one
SELECT
    COUNT(*)
FROM
    packing_lists
WHERE
    user_id = $1
`

func (q *Queries) PackingListGetAllByUserCount(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, packingListGetAllByUserCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const packingListUpdate = `-- name: PackingListUpdate :one
UPDATE
    packing_lists
SET
    name = COALESCE($1, name),
    description = COALESCE($2, description),
    due_date = COALESCE($3, due_date),
    status = COALESCE($4, status),
    days = COALESCE($5, days),
    tags = CASE
        WHEN $6::bool THEN $7
        ELSE tags
    END
WHERE
    user_id = $8
    AND id = $9 RETURNING id, created_at, updated_at, user_id, name, description, status, due_date, tags, days
`

type PackingListUpdateParams struct {
	Name        *string
	Description *string
	DueDate     pgtype.Date
	Status      *string
	Days        *int32
	UpdateTags  bool
	Tags        []string
	UserID      uuid.UUID
	ID          uuid.UUID
}

func (q *Queries) PackingListUpdate(ctx context.Context, arg PackingListUpdateParams) (PackingList, error) {
	row := q.db.QueryRow(ctx, packingListUpdate,
		arg.Name,
		arg.Description,
		arg.DueDate,
		arg.Status,
		arg.Days,
		arg.UpdateTags,
		arg.Tags,
		arg.UserID,
		arg.ID,
	)
	var i PackingList
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.DueDate,
		&i.Tags,
		&i.Days,
	)
	return i, err
}
